// This file was generated by gir (d121f7e) from gir-files (71d73f0)
// DO NOT EDIT

use ffi;
use glib_ffi;
use glib::error::ErrorDomain;
use glib::translate::*;

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum AxisUse {
    Ignore,
    X,
    Y,
    Pressure,
    Xtilt,
    Ytilt,
    Wheel,
    Distance,
    Rotation,
    Slider,
    Last,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for AxisUse {
    type GlibType = ffi::GdkAxisUse;

    fn to_glib(&self) -> ffi::GdkAxisUse {
        match *self {
            AxisUse::Ignore => ffi::GDK_AXIS_IGNORE,
            AxisUse::X => ffi::GDK_AXIS_X,
            AxisUse::Y => ffi::GDK_AXIS_Y,
            AxisUse::Pressure => ffi::GDK_AXIS_PRESSURE,
            AxisUse::Xtilt => ffi::GDK_AXIS_XTILT,
            AxisUse::Ytilt => ffi::GDK_AXIS_YTILT,
            AxisUse::Wheel => ffi::GDK_AXIS_WHEEL,
            AxisUse::Distance => ffi::GDK_AXIS_DISTANCE,
            AxisUse::Rotation => ffi::GDK_AXIS_ROTATION,
            AxisUse::Slider => ffi::GDK_AXIS_SLIDER,
            AxisUse::Last => ffi::GDK_AXIS_LAST,
            AxisUse::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkAxisUse> for AxisUse {
    fn from_glib(value: ffi::GdkAxisUse) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_AXIS_IGNORE => AxisUse::Ignore,
            ffi::GDK_AXIS_X => AxisUse::X,
            ffi::GDK_AXIS_Y => AxisUse::Y,
            ffi::GDK_AXIS_PRESSURE => AxisUse::Pressure,
            ffi::GDK_AXIS_XTILT => AxisUse::Xtilt,
            ffi::GDK_AXIS_YTILT => AxisUse::Ytilt,
            ffi::GDK_AXIS_WHEEL => AxisUse::Wheel,
            ffi::GDK_AXIS_DISTANCE => AxisUse::Distance,
            ffi::GDK_AXIS_ROTATION => AxisUse::Rotation,
            ffi::GDK_AXIS_SLIDER => AxisUse::Slider,
            ffi::GDK_AXIS_LAST => AxisUse::Last,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ByteOrder {
    LsbFirst,
    MsbFirst,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ByteOrder {
    type GlibType = ffi::GdkByteOrder;

    fn to_glib(&self) -> ffi::GdkByteOrder {
        match *self {
            ByteOrder::LsbFirst => ffi::GDK_LSB_FIRST,
            ByteOrder::MsbFirst => ffi::GDK_MSB_FIRST,
            ByteOrder::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkByteOrder> for ByteOrder {
    fn from_glib(value: ffi::GdkByteOrder) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_LSB_FIRST => ByteOrder::LsbFirst,
            ffi::GDK_MSB_FIRST => ByteOrder::MsbFirst,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CrossingMode {
    Normal,
    Grab,
    Ungrab,
    GtkGrab,
    GtkUngrab,
    StateChanged,
    TouchBegin,
    TouchEnd,
    DeviceSwitch,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CrossingMode {
    type GlibType = ffi::GdkCrossingMode;

    fn to_glib(&self) -> ffi::GdkCrossingMode {
        match *self {
            CrossingMode::Normal => ffi::GDK_CROSSING_NORMAL,
            CrossingMode::Grab => ffi::GDK_CROSSING_GRAB,
            CrossingMode::Ungrab => ffi::GDK_CROSSING_UNGRAB,
            CrossingMode::GtkGrab => ffi::GDK_CROSSING_GTK_GRAB,
            CrossingMode::GtkUngrab => ffi::GDK_CROSSING_GTK_UNGRAB,
            CrossingMode::StateChanged => ffi::GDK_CROSSING_STATE_CHANGED,
            CrossingMode::TouchBegin => ffi::GDK_CROSSING_TOUCH_BEGIN,
            CrossingMode::TouchEnd => ffi::GDK_CROSSING_TOUCH_END,
            CrossingMode::DeviceSwitch => ffi::GDK_CROSSING_DEVICE_SWITCH,
            CrossingMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkCrossingMode> for CrossingMode {
    fn from_glib(value: ffi::GdkCrossingMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_CROSSING_NORMAL => CrossingMode::Normal,
            ffi::GDK_CROSSING_GRAB => CrossingMode::Grab,
            ffi::GDK_CROSSING_UNGRAB => CrossingMode::Ungrab,
            ffi::GDK_CROSSING_GTK_GRAB => CrossingMode::GtkGrab,
            ffi::GDK_CROSSING_GTK_UNGRAB => CrossingMode::GtkUngrab,
            ffi::GDK_CROSSING_STATE_CHANGED => CrossingMode::StateChanged,
            ffi::GDK_CROSSING_TOUCH_BEGIN => CrossingMode::TouchBegin,
            ffi::GDK_CROSSING_TOUCH_END => CrossingMode::TouchEnd,
            ffi::GDK_CROSSING_DEVICE_SWITCH => CrossingMode::DeviceSwitch,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CursorType {
    XCursor,
    Arrow,
    BasedArrowDown,
    BasedArrowUp,
    Boat,
    Bogosity,
    BottomLeftCorner,
    BottomRightCorner,
    BottomSide,
    BottomTee,
    BoxSpiral,
    CenterPtr,
    Circle,
    Clock,
    CoffeeMug,
    Cross,
    CrossReverse,
    Crosshair,
    DiamondCross,
    Dot,
    Dotbox,
    DoubleArrow,
    DraftLarge,
    DraftSmall,
    DrapedBox,
    Exchange,
    Fleur,
    Gobbler,
    Gumby,
    Hand1,
    Hand2,
    Heart,
    Icon,
    IronCross,
    LeftPtr,
    LeftSide,
    LeftTee,
    Leftbutton,
    LlAngle,
    LrAngle,
    Man,
    Middlebutton,
    Mouse,
    Pencil,
    Pirate,
    Plus,
    QuestionArrow,
    RightPtr,
    RightSide,
    RightTee,
    Rightbutton,
    RtlLogo,
    Sailboat,
    SbDownArrow,
    SbHDoubleArrow,
    SbLeftArrow,
    SbRightArrow,
    SbUpArrow,
    SbVDoubleArrow,
    Shuttle,
    Sizing,
    Spider,
    Spraycan,
    Star,
    Target,
    Tcross,
    TopLeftArrow,
    TopLeftCorner,
    TopRightCorner,
    TopSide,
    TopTee,
    Trek,
    UlAngle,
    Umbrella,
    UrAngle,
    Watch,
    Xterm,
    LastCursor,
    BlankCursor,
    CursorIsPixmap,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CursorType {
    type GlibType = ffi::GdkCursorType;

    fn to_glib(&self) -> ffi::GdkCursorType {
        match *self {
            CursorType::XCursor => ffi::GDK_X_CURSOR,
            CursorType::Arrow => ffi::GDK_ARROW,
            CursorType::BasedArrowDown => ffi::GDK_BASED_ARROW_DOWN,
            CursorType::BasedArrowUp => ffi::GDK_BASED_ARROW_UP,
            CursorType::Boat => ffi::GDK_BOAT,
            CursorType::Bogosity => ffi::GDK_BOGOSITY,
            CursorType::BottomLeftCorner => ffi::GDK_BOTTOM_LEFT_CORNER,
            CursorType::BottomRightCorner => ffi::GDK_BOTTOM_RIGHT_CORNER,
            CursorType::BottomSide => ffi::GDK_BOTTOM_SIDE,
            CursorType::BottomTee => ffi::GDK_BOTTOM_TEE,
            CursorType::BoxSpiral => ffi::GDK_BOX_SPIRAL,
            CursorType::CenterPtr => ffi::GDK_CENTER_PTR,
            CursorType::Circle => ffi::GDK_CIRCLE,
            CursorType::Clock => ffi::GDK_CLOCK,
            CursorType::CoffeeMug => ffi::GDK_COFFEE_MUG,
            CursorType::Cross => ffi::GDK_CROSS,
            CursorType::CrossReverse => ffi::GDK_CROSS_REVERSE,
            CursorType::Crosshair => ffi::GDK_CROSSHAIR,
            CursorType::DiamondCross => ffi::GDK_DIAMOND_CROSS,
            CursorType::Dot => ffi::GDK_DOT,
            CursorType::Dotbox => ffi::GDK_DOTBOX,
            CursorType::DoubleArrow => ffi::GDK_DOUBLE_ARROW,
            CursorType::DraftLarge => ffi::GDK_DRAFT_LARGE,
            CursorType::DraftSmall => ffi::GDK_DRAFT_SMALL,
            CursorType::DrapedBox => ffi::GDK_DRAPED_BOX,
            CursorType::Exchange => ffi::GDK_EXCHANGE,
            CursorType::Fleur => ffi::GDK_FLEUR,
            CursorType::Gobbler => ffi::GDK_GOBBLER,
            CursorType::Gumby => ffi::GDK_GUMBY,
            CursorType::Hand1 => ffi::GDK_HAND1,
            CursorType::Hand2 => ffi::GDK_HAND2,
            CursorType::Heart => ffi::GDK_HEART,
            CursorType::Icon => ffi::GDK_ICON,
            CursorType::IronCross => ffi::GDK_IRON_CROSS,
            CursorType::LeftPtr => ffi::GDK_LEFT_PTR,
            CursorType::LeftSide => ffi::GDK_LEFT_SIDE,
            CursorType::LeftTee => ffi::GDK_LEFT_TEE,
            CursorType::Leftbutton => ffi::GDK_LEFTBUTTON,
            CursorType::LlAngle => ffi::GDK_LL_ANGLE,
            CursorType::LrAngle => ffi::GDK_LR_ANGLE,
            CursorType::Man => ffi::GDK_MAN,
            CursorType::Middlebutton => ffi::GDK_MIDDLEBUTTON,
            CursorType::Mouse => ffi::GDK_MOUSE,
            CursorType::Pencil => ffi::GDK_PENCIL,
            CursorType::Pirate => ffi::GDK_PIRATE,
            CursorType::Plus => ffi::GDK_PLUS,
            CursorType::QuestionArrow => ffi::GDK_QUESTION_ARROW,
            CursorType::RightPtr => ffi::GDK_RIGHT_PTR,
            CursorType::RightSide => ffi::GDK_RIGHT_SIDE,
            CursorType::RightTee => ffi::GDK_RIGHT_TEE,
            CursorType::Rightbutton => ffi::GDK_RIGHTBUTTON,
            CursorType::RtlLogo => ffi::GDK_RTL_LOGO,
            CursorType::Sailboat => ffi::GDK_SAILBOAT,
            CursorType::SbDownArrow => ffi::GDK_SB_DOWN_ARROW,
            CursorType::SbHDoubleArrow => ffi::GDK_SB_H_DOUBLE_ARROW,
            CursorType::SbLeftArrow => ffi::GDK_SB_LEFT_ARROW,
            CursorType::SbRightArrow => ffi::GDK_SB_RIGHT_ARROW,
            CursorType::SbUpArrow => ffi::GDK_SB_UP_ARROW,
            CursorType::SbVDoubleArrow => ffi::GDK_SB_V_DOUBLE_ARROW,
            CursorType::Shuttle => ffi::GDK_SHUTTLE,
            CursorType::Sizing => ffi::GDK_SIZING,
            CursorType::Spider => ffi::GDK_SPIDER,
            CursorType::Spraycan => ffi::GDK_SPRAYCAN,
            CursorType::Star => ffi::GDK_STAR,
            CursorType::Target => ffi::GDK_TARGET,
            CursorType::Tcross => ffi::GDK_TCROSS,
            CursorType::TopLeftArrow => ffi::GDK_TOP_LEFT_ARROW,
            CursorType::TopLeftCorner => ffi::GDK_TOP_LEFT_CORNER,
            CursorType::TopRightCorner => ffi::GDK_TOP_RIGHT_CORNER,
            CursorType::TopSide => ffi::GDK_TOP_SIDE,
            CursorType::TopTee => ffi::GDK_TOP_TEE,
            CursorType::Trek => ffi::GDK_TREK,
            CursorType::UlAngle => ffi::GDK_UL_ANGLE,
            CursorType::Umbrella => ffi::GDK_UMBRELLA,
            CursorType::UrAngle => ffi::GDK_UR_ANGLE,
            CursorType::Watch => ffi::GDK_WATCH,
            CursorType::Xterm => ffi::GDK_XTERM,
            CursorType::LastCursor => ffi::GDK_LAST_CURSOR,
            CursorType::BlankCursor => ffi::GDK_BLANK_CURSOR,
            CursorType::CursorIsPixmap => ffi::GDK_CURSOR_IS_PIXMAP,
            CursorType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkCursorType> for CursorType {
    fn from_glib(value: ffi::GdkCursorType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_X_CURSOR => CursorType::XCursor,
            ffi::GDK_ARROW => CursorType::Arrow,
            ffi::GDK_BASED_ARROW_DOWN => CursorType::BasedArrowDown,
            ffi::GDK_BASED_ARROW_UP => CursorType::BasedArrowUp,
            ffi::GDK_BOAT => CursorType::Boat,
            ffi::GDK_BOGOSITY => CursorType::Bogosity,
            ffi::GDK_BOTTOM_LEFT_CORNER => CursorType::BottomLeftCorner,
            ffi::GDK_BOTTOM_RIGHT_CORNER => CursorType::BottomRightCorner,
            ffi::GDK_BOTTOM_SIDE => CursorType::BottomSide,
            ffi::GDK_BOTTOM_TEE => CursorType::BottomTee,
            ffi::GDK_BOX_SPIRAL => CursorType::BoxSpiral,
            ffi::GDK_CENTER_PTR => CursorType::CenterPtr,
            ffi::GDK_CIRCLE => CursorType::Circle,
            ffi::GDK_CLOCK => CursorType::Clock,
            ffi::GDK_COFFEE_MUG => CursorType::CoffeeMug,
            ffi::GDK_CROSS => CursorType::Cross,
            ffi::GDK_CROSS_REVERSE => CursorType::CrossReverse,
            ffi::GDK_CROSSHAIR => CursorType::Crosshair,
            ffi::GDK_DIAMOND_CROSS => CursorType::DiamondCross,
            ffi::GDK_DOT => CursorType::Dot,
            ffi::GDK_DOTBOX => CursorType::Dotbox,
            ffi::GDK_DOUBLE_ARROW => CursorType::DoubleArrow,
            ffi::GDK_DRAFT_LARGE => CursorType::DraftLarge,
            ffi::GDK_DRAFT_SMALL => CursorType::DraftSmall,
            ffi::GDK_DRAPED_BOX => CursorType::DrapedBox,
            ffi::GDK_EXCHANGE => CursorType::Exchange,
            ffi::GDK_FLEUR => CursorType::Fleur,
            ffi::GDK_GOBBLER => CursorType::Gobbler,
            ffi::GDK_GUMBY => CursorType::Gumby,
            ffi::GDK_HAND1 => CursorType::Hand1,
            ffi::GDK_HAND2 => CursorType::Hand2,
            ffi::GDK_HEART => CursorType::Heart,
            ffi::GDK_ICON => CursorType::Icon,
            ffi::GDK_IRON_CROSS => CursorType::IronCross,
            ffi::GDK_LEFT_PTR => CursorType::LeftPtr,
            ffi::GDK_LEFT_SIDE => CursorType::LeftSide,
            ffi::GDK_LEFT_TEE => CursorType::LeftTee,
            ffi::GDK_LEFTBUTTON => CursorType::Leftbutton,
            ffi::GDK_LL_ANGLE => CursorType::LlAngle,
            ffi::GDK_LR_ANGLE => CursorType::LrAngle,
            ffi::GDK_MAN => CursorType::Man,
            ffi::GDK_MIDDLEBUTTON => CursorType::Middlebutton,
            ffi::GDK_MOUSE => CursorType::Mouse,
            ffi::GDK_PENCIL => CursorType::Pencil,
            ffi::GDK_PIRATE => CursorType::Pirate,
            ffi::GDK_PLUS => CursorType::Plus,
            ffi::GDK_QUESTION_ARROW => CursorType::QuestionArrow,
            ffi::GDK_RIGHT_PTR => CursorType::RightPtr,
            ffi::GDK_RIGHT_SIDE => CursorType::RightSide,
            ffi::GDK_RIGHT_TEE => CursorType::RightTee,
            ffi::GDK_RIGHTBUTTON => CursorType::Rightbutton,
            ffi::GDK_RTL_LOGO => CursorType::RtlLogo,
            ffi::GDK_SAILBOAT => CursorType::Sailboat,
            ffi::GDK_SB_DOWN_ARROW => CursorType::SbDownArrow,
            ffi::GDK_SB_H_DOUBLE_ARROW => CursorType::SbHDoubleArrow,
            ffi::GDK_SB_LEFT_ARROW => CursorType::SbLeftArrow,
            ffi::GDK_SB_RIGHT_ARROW => CursorType::SbRightArrow,
            ffi::GDK_SB_UP_ARROW => CursorType::SbUpArrow,
            ffi::GDK_SB_V_DOUBLE_ARROW => CursorType::SbVDoubleArrow,
            ffi::GDK_SHUTTLE => CursorType::Shuttle,
            ffi::GDK_SIZING => CursorType::Sizing,
            ffi::GDK_SPIDER => CursorType::Spider,
            ffi::GDK_SPRAYCAN => CursorType::Spraycan,
            ffi::GDK_STAR => CursorType::Star,
            ffi::GDK_TARGET => CursorType::Target,
            ffi::GDK_TCROSS => CursorType::Tcross,
            ffi::GDK_TOP_LEFT_ARROW => CursorType::TopLeftArrow,
            ffi::GDK_TOP_LEFT_CORNER => CursorType::TopLeftCorner,
            ffi::GDK_TOP_RIGHT_CORNER => CursorType::TopRightCorner,
            ffi::GDK_TOP_SIDE => CursorType::TopSide,
            ffi::GDK_TOP_TEE => CursorType::TopTee,
            ffi::GDK_TREK => CursorType::Trek,
            ffi::GDK_UL_ANGLE => CursorType::UlAngle,
            ffi::GDK_UMBRELLA => CursorType::Umbrella,
            ffi::GDK_UR_ANGLE => CursorType::UrAngle,
            ffi::GDK_WATCH => CursorType::Watch,
            ffi::GDK_XTERM => CursorType::Xterm,
            ffi::GDK_LAST_CURSOR => CursorType::LastCursor,
            ffi::GDK_BLANK_CURSOR => CursorType::BlankCursor,
            ffi::GDK_CURSOR_IS_PIXMAP => CursorType::CursorIsPixmap,
        }
    }
}

#[cfg(feature = "v3_22")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DeviceToolType {
    Unknown,
    Pen,
    Eraser,
    Brush,
    Pencil,
    Airbrush,
    Mouse,
    Lens,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_22")]
#[doc(hidden)]
impl ToGlib for DeviceToolType {
    type GlibType = ffi::GdkDeviceToolType;

    fn to_glib(&self) -> ffi::GdkDeviceToolType {
        match *self {
            DeviceToolType::Unknown => ffi::GDK_DEVICE_TOOL_TYPE_UNKNOWN,
            DeviceToolType::Pen => ffi::GDK_DEVICE_TOOL_TYPE_PEN,
            DeviceToolType::Eraser => ffi::GDK_DEVICE_TOOL_TYPE_ERASER,
            DeviceToolType::Brush => ffi::GDK_DEVICE_TOOL_TYPE_BRUSH,
            DeviceToolType::Pencil => ffi::GDK_DEVICE_TOOL_TYPE_PENCIL,
            DeviceToolType::Airbrush => ffi::GDK_DEVICE_TOOL_TYPE_AIRBRUSH,
            DeviceToolType::Mouse => ffi::GDK_DEVICE_TOOL_TYPE_MOUSE,
            DeviceToolType::Lens => ffi::GDK_DEVICE_TOOL_TYPE_LENS,
            DeviceToolType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_22")]
#[doc(hidden)]
impl FromGlib<ffi::GdkDeviceToolType> for DeviceToolType {
    fn from_glib(value: ffi::GdkDeviceToolType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_DEVICE_TOOL_TYPE_UNKNOWN => DeviceToolType::Unknown,
            ffi::GDK_DEVICE_TOOL_TYPE_PEN => DeviceToolType::Pen,
            ffi::GDK_DEVICE_TOOL_TYPE_ERASER => DeviceToolType::Eraser,
            ffi::GDK_DEVICE_TOOL_TYPE_BRUSH => DeviceToolType::Brush,
            ffi::GDK_DEVICE_TOOL_TYPE_PENCIL => DeviceToolType::Pencil,
            ffi::GDK_DEVICE_TOOL_TYPE_AIRBRUSH => DeviceToolType::Airbrush,
            ffi::GDK_DEVICE_TOOL_TYPE_MOUSE => DeviceToolType::Mouse,
            ffi::GDK_DEVICE_TOOL_TYPE_LENS => DeviceToolType::Lens,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DeviceType {
    Master,
    Slave,
    Floating,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for DeviceType {
    type GlibType = ffi::GdkDeviceType;

    fn to_glib(&self) -> ffi::GdkDeviceType {
        match *self {
            DeviceType::Master => ffi::GDK_DEVICE_TYPE_MASTER,
            DeviceType::Slave => ffi::GDK_DEVICE_TYPE_SLAVE,
            DeviceType::Floating => ffi::GDK_DEVICE_TYPE_FLOATING,
            DeviceType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkDeviceType> for DeviceType {
    fn from_glib(value: ffi::GdkDeviceType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_DEVICE_TYPE_MASTER => DeviceType::Master,
            ffi::GDK_DEVICE_TYPE_SLAVE => DeviceType::Slave,
            ffi::GDK_DEVICE_TYPE_FLOATING => DeviceType::Floating,
        }
    }
}

#[cfg(feature = "v3_20")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DragCancelReason {
    NoTarget,
    UserCancelled,
    Error,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_20")]
#[doc(hidden)]
impl ToGlib for DragCancelReason {
    type GlibType = ffi::GdkDragCancelReason;

    fn to_glib(&self) -> ffi::GdkDragCancelReason {
        match *self {
            DragCancelReason::NoTarget => ffi::GDK_DRAG_CANCEL_NO_TARGET,
            DragCancelReason::UserCancelled => ffi::GDK_DRAG_CANCEL_USER_CANCELLED,
            DragCancelReason::Error => ffi::GDK_DRAG_CANCEL_ERROR,
            DragCancelReason::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_20")]
#[doc(hidden)]
impl FromGlib<ffi::GdkDragCancelReason> for DragCancelReason {
    fn from_glib(value: ffi::GdkDragCancelReason) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_DRAG_CANCEL_NO_TARGET => DragCancelReason::NoTarget,
            ffi::GDK_DRAG_CANCEL_USER_CANCELLED => DragCancelReason::UserCancelled,
            ffi::GDK_DRAG_CANCEL_ERROR => DragCancelReason::Error,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DragProtocol {
    None,
    Motif,
    Xdnd,
    Rootwin,
    Win32Dropfiles,
    Ole2,
    Local,
    Wayland,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for DragProtocol {
    type GlibType = ffi::GdkDragProtocol;

    fn to_glib(&self) -> ffi::GdkDragProtocol {
        match *self {
            DragProtocol::None => ffi::GDK_DRAG_PROTO_NONE,
            DragProtocol::Motif => ffi::GDK_DRAG_PROTO_MOTIF,
            DragProtocol::Xdnd => ffi::GDK_DRAG_PROTO_XDND,
            DragProtocol::Rootwin => ffi::GDK_DRAG_PROTO_ROOTWIN,
            DragProtocol::Win32Dropfiles => ffi::GDK_DRAG_PROTO_WIN32_DROPFILES,
            DragProtocol::Ole2 => ffi::GDK_DRAG_PROTO_OLE2,
            DragProtocol::Local => ffi::GDK_DRAG_PROTO_LOCAL,
            DragProtocol::Wayland => ffi::GDK_DRAG_PROTO_WAYLAND,
            DragProtocol::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkDragProtocol> for DragProtocol {
    fn from_glib(value: ffi::GdkDragProtocol) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_DRAG_PROTO_NONE => DragProtocol::None,
            ffi::GDK_DRAG_PROTO_MOTIF => DragProtocol::Motif,
            ffi::GDK_DRAG_PROTO_XDND => DragProtocol::Xdnd,
            ffi::GDK_DRAG_PROTO_ROOTWIN => DragProtocol::Rootwin,
            ffi::GDK_DRAG_PROTO_WIN32_DROPFILES => DragProtocol::Win32Dropfiles,
            ffi::GDK_DRAG_PROTO_OLE2 => DragProtocol::Ole2,
            ffi::GDK_DRAG_PROTO_LOCAL => DragProtocol::Local,
            ffi::GDK_DRAG_PROTO_WAYLAND => DragProtocol::Wayland,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum EventType {
    Nothing,
    Delete,
    Destroy,
    Expose,
    MotionNotify,
    ButtonPress,
    DoubleButtonPress,
    TripleButtonPress,
    ButtonRelease,
    KeyPress,
    KeyRelease,
    EnterNotify,
    LeaveNotify,
    FocusChange,
    Configure,
    Map,
    Unmap,
    PropertyNotify,
    SelectionClear,
    SelectionRequest,
    SelectionNotify,
    ProximityIn,
    ProximityOut,
    DragEnter,
    DragLeave,
    DragMotion,
    DragStatus,
    DropStart,
    DropFinished,
    ClientEvent,
    VisibilityNotify,
    Scroll,
    WindowState,
    Setting,
    OwnerChange,
    GrabBroken,
    Damage,
    TouchBegin,
    TouchUpdate,
    TouchEnd,
    TouchCancel,
    #[cfg(feature = "v3_18")]
    TouchpadSwipe,
    #[cfg(feature = "v3_18")]
    TouchpadPinch,
    PadButtonPress,
    PadButtonRelease,
    PadRing,
    PadStrip,
    PadGroupMode,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for EventType {
    type GlibType = ffi::GdkEventType;

    fn to_glib(&self) -> ffi::GdkEventType {
        match *self {
            EventType::Nothing => ffi::GDK_NOTHING,
            EventType::Delete => ffi::GDK_DELETE,
            EventType::Destroy => ffi::GDK_DESTROY,
            EventType::Expose => ffi::GDK_EXPOSE,
            EventType::MotionNotify => ffi::GDK_MOTION_NOTIFY,
            EventType::ButtonPress => ffi::GDK_BUTTON_PRESS,
            EventType::DoubleButtonPress => ffi::GDK_DOUBLE_BUTTON_PRESS,
            EventType::TripleButtonPress => ffi::GDK_TRIPLE_BUTTON_PRESS,
            EventType::ButtonRelease => ffi::GDK_BUTTON_RELEASE,
            EventType::KeyPress => ffi::GDK_KEY_PRESS,
            EventType::KeyRelease => ffi::GDK_KEY_RELEASE,
            EventType::EnterNotify => ffi::GDK_ENTER_NOTIFY,
            EventType::LeaveNotify => ffi::GDK_LEAVE_NOTIFY,
            EventType::FocusChange => ffi::GDK_FOCUS_CHANGE,
            EventType::Configure => ffi::GDK_CONFIGURE,
            EventType::Map => ffi::GDK_MAP,
            EventType::Unmap => ffi::GDK_UNMAP,
            EventType::PropertyNotify => ffi::GDK_PROPERTY_NOTIFY,
            EventType::SelectionClear => ffi::GDK_SELECTION_CLEAR,
            EventType::SelectionRequest => ffi::GDK_SELECTION_REQUEST,
            EventType::SelectionNotify => ffi::GDK_SELECTION_NOTIFY,
            EventType::ProximityIn => ffi::GDK_PROXIMITY_IN,
            EventType::ProximityOut => ffi::GDK_PROXIMITY_OUT,
            EventType::DragEnter => ffi::GDK_DRAG_ENTER,
            EventType::DragLeave => ffi::GDK_DRAG_LEAVE,
            EventType::DragMotion => ffi::GDK_DRAG_MOTION,
            EventType::DragStatus => ffi::GDK_DRAG_STATUS,
            EventType::DropStart => ffi::GDK_DROP_START,
            EventType::DropFinished => ffi::GDK_DROP_FINISHED,
            EventType::ClientEvent => ffi::GDK_CLIENT_EVENT,
            EventType::VisibilityNotify => ffi::GDK_VISIBILITY_NOTIFY,
            EventType::Scroll => ffi::GDK_SCROLL,
            EventType::WindowState => ffi::GDK_WINDOW_STATE,
            EventType::Setting => ffi::GDK_SETTING,
            EventType::OwnerChange => ffi::GDK_OWNER_CHANGE,
            EventType::GrabBroken => ffi::GDK_GRAB_BROKEN,
            EventType::Damage => ffi::GDK_DAMAGE,
            EventType::TouchBegin => ffi::GDK_TOUCH_BEGIN,
            EventType::TouchUpdate => ffi::GDK_TOUCH_UPDATE,
            EventType::TouchEnd => ffi::GDK_TOUCH_END,
            EventType::TouchCancel => ffi::GDK_TOUCH_CANCEL,
            #[cfg(feature = "v3_18")]
            EventType::TouchpadSwipe => ffi::GDK_TOUCHPAD_SWIPE,
            #[cfg(feature = "v3_18")]
            EventType::TouchpadPinch => ffi::GDK_TOUCHPAD_PINCH,
            EventType::PadButtonPress => ffi::GDK_PAD_BUTTON_PRESS,
            EventType::PadButtonRelease => ffi::GDK_PAD_BUTTON_RELEASE,
            EventType::PadRing => ffi::GDK_PAD_RING,
            EventType::PadStrip => ffi::GDK_PAD_STRIP,
            EventType::PadGroupMode => ffi::GDK_PAD_GROUP_MODE,
            EventType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkEventType> for EventType {
    fn from_glib(value: ffi::GdkEventType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_NOTHING => EventType::Nothing,
            ffi::GDK_DELETE => EventType::Delete,
            ffi::GDK_DESTROY => EventType::Destroy,
            ffi::GDK_EXPOSE => EventType::Expose,
            ffi::GDK_MOTION_NOTIFY => EventType::MotionNotify,
            ffi::GDK_BUTTON_PRESS => EventType::ButtonPress,
            ffi::GDK_DOUBLE_BUTTON_PRESS => EventType::DoubleButtonPress,
            ffi::GDK_TRIPLE_BUTTON_PRESS => EventType::TripleButtonPress,
            ffi::GDK_BUTTON_RELEASE => EventType::ButtonRelease,
            ffi::GDK_KEY_PRESS => EventType::KeyPress,
            ffi::GDK_KEY_RELEASE => EventType::KeyRelease,
            ffi::GDK_ENTER_NOTIFY => EventType::EnterNotify,
            ffi::GDK_LEAVE_NOTIFY => EventType::LeaveNotify,
            ffi::GDK_FOCUS_CHANGE => EventType::FocusChange,
            ffi::GDK_CONFIGURE => EventType::Configure,
            ffi::GDK_MAP => EventType::Map,
            ffi::GDK_UNMAP => EventType::Unmap,
            ffi::GDK_PROPERTY_NOTIFY => EventType::PropertyNotify,
            ffi::GDK_SELECTION_CLEAR => EventType::SelectionClear,
            ffi::GDK_SELECTION_REQUEST => EventType::SelectionRequest,
            ffi::GDK_SELECTION_NOTIFY => EventType::SelectionNotify,
            ffi::GDK_PROXIMITY_IN => EventType::ProximityIn,
            ffi::GDK_PROXIMITY_OUT => EventType::ProximityOut,
            ffi::GDK_DRAG_ENTER => EventType::DragEnter,
            ffi::GDK_DRAG_LEAVE => EventType::DragLeave,
            ffi::GDK_DRAG_MOTION => EventType::DragMotion,
            ffi::GDK_DRAG_STATUS => EventType::DragStatus,
            ffi::GDK_DROP_START => EventType::DropStart,
            ffi::GDK_DROP_FINISHED => EventType::DropFinished,
            ffi::GDK_CLIENT_EVENT => EventType::ClientEvent,
            ffi::GDK_VISIBILITY_NOTIFY => EventType::VisibilityNotify,
            ffi::GDK_SCROLL => EventType::Scroll,
            ffi::GDK_WINDOW_STATE => EventType::WindowState,
            ffi::GDK_SETTING => EventType::Setting,
            ffi::GDK_OWNER_CHANGE => EventType::OwnerChange,
            ffi::GDK_GRAB_BROKEN => EventType::GrabBroken,
            ffi::GDK_DAMAGE => EventType::Damage,
            ffi::GDK_TOUCH_BEGIN => EventType::TouchBegin,
            ffi::GDK_TOUCH_UPDATE => EventType::TouchUpdate,
            ffi::GDK_TOUCH_END => EventType::TouchEnd,
            ffi::GDK_TOUCH_CANCEL => EventType::TouchCancel,
            #[cfg(feature = "v3_18")]
            ffi::GDK_TOUCHPAD_SWIPE => EventType::TouchpadSwipe,
            #[cfg(feature = "v3_18")]
            ffi::GDK_TOUCHPAD_PINCH => EventType::TouchpadPinch,
            ffi::GDK_PAD_BUTTON_PRESS => EventType::PadButtonPress,
            ffi::GDK_PAD_BUTTON_RELEASE => EventType::PadButtonRelease,
            ffi::GDK_PAD_RING => EventType::PadRing,
            ffi::GDK_PAD_STRIP => EventType::PadStrip,
            ffi::GDK_PAD_GROUP_MODE => EventType::PadGroupMode,
        }
    }
}

#[cfg(feature = "v3_8")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FullscreenMode {
    CurrentMonitor,
    AllMonitors,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_8")]
#[doc(hidden)]
impl ToGlib for FullscreenMode {
    type GlibType = ffi::GdkFullscreenMode;

    fn to_glib(&self) -> ffi::GdkFullscreenMode {
        match *self {
            FullscreenMode::CurrentMonitor => ffi::GDK_FULLSCREEN_ON_CURRENT_MONITOR,
            FullscreenMode::AllMonitors => ffi::GDK_FULLSCREEN_ON_ALL_MONITORS,
            FullscreenMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_8")]
#[doc(hidden)]
impl FromGlib<ffi::GdkFullscreenMode> for FullscreenMode {
    fn from_glib(value: ffi::GdkFullscreenMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_FULLSCREEN_ON_CURRENT_MONITOR => FullscreenMode::CurrentMonitor,
            ffi::GDK_FULLSCREEN_ON_ALL_MONITORS => FullscreenMode::AllMonitors,
        }
    }
}

#[cfg(feature = "v3_16")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum GLError {
    NotAvailable,
    UnsupportedFormat,
    UnsupportedProfile,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_16")]
#[doc(hidden)]
impl ToGlib for GLError {
    type GlibType = ffi::GdkGLError;

    fn to_glib(&self) -> ffi::GdkGLError {
        match *self {
            GLError::NotAvailable => ffi::GDK_GL_ERROR_NOT_AVAILABLE,
            GLError::UnsupportedFormat => ffi::GDK_GL_ERROR_UNSUPPORTED_FORMAT,
            GLError::UnsupportedProfile => ffi::GDK_GL_ERROR_UNSUPPORTED_PROFILE,
            GLError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_16")]
#[doc(hidden)]
impl FromGlib<ffi::GdkGLError> for GLError {
    fn from_glib(value: ffi::GdkGLError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_GL_ERROR_NOT_AVAILABLE => GLError::NotAvailable,
            ffi::GDK_GL_ERROR_UNSUPPORTED_FORMAT => GLError::UnsupportedFormat,
            ffi::GDK_GL_ERROR_UNSUPPORTED_PROFILE => GLError::UnsupportedProfile,
        }
    }
}

#[cfg(feature = "v3_16")]
impl ErrorDomain for GLError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gdk_gl_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GDK_GL_ERROR_NOT_AVAILABLE as i32 => Some(GLError::NotAvailable),
            x if x == ffi::GDK_GL_ERROR_UNSUPPORTED_FORMAT as i32 => Some(GLError::UnsupportedFormat),
            x if x == ffi::GDK_GL_ERROR_UNSUPPORTED_PROFILE as i32 => Some(GLError::UnsupportedProfile),
            _ => Some(GLError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum GrabOwnership {
    None,
    Window,
    Application,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for GrabOwnership {
    type GlibType = ffi::GdkGrabOwnership;

    fn to_glib(&self) -> ffi::GdkGrabOwnership {
        match *self {
            GrabOwnership::None => ffi::GDK_OWNERSHIP_NONE,
            GrabOwnership::Window => ffi::GDK_OWNERSHIP_WINDOW,
            GrabOwnership::Application => ffi::GDK_OWNERSHIP_APPLICATION,
            GrabOwnership::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkGrabOwnership> for GrabOwnership {
    fn from_glib(value: ffi::GdkGrabOwnership) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_OWNERSHIP_NONE => GrabOwnership::None,
            ffi::GDK_OWNERSHIP_WINDOW => GrabOwnership::Window,
            ffi::GDK_OWNERSHIP_APPLICATION => GrabOwnership::Application,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum GrabStatus {
    Success,
    AlreadyGrabbed,
    InvalidTime,
    NotViewable,
    Frozen,
    Failed,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for GrabStatus {
    type GlibType = ffi::GdkGrabStatus;

    fn to_glib(&self) -> ffi::GdkGrabStatus {
        match *self {
            GrabStatus::Success => ffi::GDK_GRAB_SUCCESS,
            GrabStatus::AlreadyGrabbed => ffi::GDK_GRAB_ALREADY_GRABBED,
            GrabStatus::InvalidTime => ffi::GDK_GRAB_INVALID_TIME,
            GrabStatus::NotViewable => ffi::GDK_GRAB_NOT_VIEWABLE,
            GrabStatus::Frozen => ffi::GDK_GRAB_FROZEN,
            GrabStatus::Failed => ffi::GDK_GRAB_FAILED,
            GrabStatus::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkGrabStatus> for GrabStatus {
    fn from_glib(value: ffi::GdkGrabStatus) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_GRAB_SUCCESS => GrabStatus::Success,
            ffi::GDK_GRAB_ALREADY_GRABBED => GrabStatus::AlreadyGrabbed,
            ffi::GDK_GRAB_INVALID_TIME => GrabStatus::InvalidTime,
            ffi::GDK_GRAB_NOT_VIEWABLE => GrabStatus::NotViewable,
            ffi::GDK_GRAB_FROZEN => GrabStatus::Frozen,
            ffi::GDK_GRAB_FAILED => GrabStatus::Failed,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Gravity {
    NorthWest,
    North,
    NorthEast,
    West,
    Center,
    East,
    SouthWest,
    South,
    SouthEast,
    Static,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for Gravity {
    type GlibType = ffi::GdkGravity;

    fn to_glib(&self) -> ffi::GdkGravity {
        match *self {
            Gravity::NorthWest => ffi::GDK_GRAVITY_NORTH_WEST,
            Gravity::North => ffi::GDK_GRAVITY_NORTH,
            Gravity::NorthEast => ffi::GDK_GRAVITY_NORTH_EAST,
            Gravity::West => ffi::GDK_GRAVITY_WEST,
            Gravity::Center => ffi::GDK_GRAVITY_CENTER,
            Gravity::East => ffi::GDK_GRAVITY_EAST,
            Gravity::SouthWest => ffi::GDK_GRAVITY_SOUTH_WEST,
            Gravity::South => ffi::GDK_GRAVITY_SOUTH,
            Gravity::SouthEast => ffi::GDK_GRAVITY_SOUTH_EAST,
            Gravity::Static => ffi::GDK_GRAVITY_STATIC,
            Gravity::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkGravity> for Gravity {
    fn from_glib(value: ffi::GdkGravity) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_GRAVITY_NORTH_WEST => Gravity::NorthWest,
            ffi::GDK_GRAVITY_NORTH => Gravity::North,
            ffi::GDK_GRAVITY_NORTH_EAST => Gravity::NorthEast,
            ffi::GDK_GRAVITY_WEST => Gravity::West,
            ffi::GDK_GRAVITY_CENTER => Gravity::Center,
            ffi::GDK_GRAVITY_EAST => Gravity::East,
            ffi::GDK_GRAVITY_SOUTH_WEST => Gravity::SouthWest,
            ffi::GDK_GRAVITY_SOUTH => Gravity::South,
            ffi::GDK_GRAVITY_SOUTH_EAST => Gravity::SouthEast,
            ffi::GDK_GRAVITY_STATIC => Gravity::Static,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum InputMode {
    Disabled,
    Screen,
    Window,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for InputMode {
    type GlibType = ffi::GdkInputMode;

    fn to_glib(&self) -> ffi::GdkInputMode {
        match *self {
            InputMode::Disabled => ffi::GDK_MODE_DISABLED,
            InputMode::Screen => ffi::GDK_MODE_SCREEN,
            InputMode::Window => ffi::GDK_MODE_WINDOW,
            InputMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkInputMode> for InputMode {
    fn from_glib(value: ffi::GdkInputMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_MODE_DISABLED => InputMode::Disabled,
            ffi::GDK_MODE_SCREEN => InputMode::Screen,
            ffi::GDK_MODE_WINDOW => InputMode::Window,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum InputSource {
    Mouse,
    Pen,
    Eraser,
    Cursor,
    Keyboard,
    Touchscreen,
    Touchpad,
    Trackpoint,
    TabletPad,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for InputSource {
    type GlibType = ffi::GdkInputSource;

    fn to_glib(&self) -> ffi::GdkInputSource {
        match *self {
            InputSource::Mouse => ffi::GDK_SOURCE_MOUSE,
            InputSource::Pen => ffi::GDK_SOURCE_PEN,
            InputSource::Eraser => ffi::GDK_SOURCE_ERASER,
            InputSource::Cursor => ffi::GDK_SOURCE_CURSOR,
            InputSource::Keyboard => ffi::GDK_SOURCE_KEYBOARD,
            InputSource::Touchscreen => ffi::GDK_SOURCE_TOUCHSCREEN,
            InputSource::Touchpad => ffi::GDK_SOURCE_TOUCHPAD,
            InputSource::Trackpoint => ffi::GDK_SOURCE_TRACKPOINT,
            InputSource::TabletPad => ffi::GDK_SOURCE_TABLET_PAD,
            InputSource::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkInputSource> for InputSource {
    fn from_glib(value: ffi::GdkInputSource) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_SOURCE_MOUSE => InputSource::Mouse,
            ffi::GDK_SOURCE_PEN => InputSource::Pen,
            ffi::GDK_SOURCE_ERASER => InputSource::Eraser,
            ffi::GDK_SOURCE_CURSOR => InputSource::Cursor,
            ffi::GDK_SOURCE_KEYBOARD => InputSource::Keyboard,
            ffi::GDK_SOURCE_TOUCHSCREEN => InputSource::Touchscreen,
            ffi::GDK_SOURCE_TOUCHPAD => InputSource::Touchpad,
            ffi::GDK_SOURCE_TRACKPOINT => InputSource::Trackpoint,
            ffi::GDK_SOURCE_TABLET_PAD => InputSource::TabletPad,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ModifierIntent {
    PrimaryAccelerator,
    ContextMenu,
    ExtendSelection,
    ModifySelection,
    NoTextInput,
    ShiftGroup,
    DefaultModMask,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ModifierIntent {
    type GlibType = ffi::GdkModifierIntent;

    fn to_glib(&self) -> ffi::GdkModifierIntent {
        match *self {
            ModifierIntent::PrimaryAccelerator => ffi::GDK_MODIFIER_INTENT_PRIMARY_ACCELERATOR,
            ModifierIntent::ContextMenu => ffi::GDK_MODIFIER_INTENT_CONTEXT_MENU,
            ModifierIntent::ExtendSelection => ffi::GDK_MODIFIER_INTENT_EXTEND_SELECTION,
            ModifierIntent::ModifySelection => ffi::GDK_MODIFIER_INTENT_MODIFY_SELECTION,
            ModifierIntent::NoTextInput => ffi::GDK_MODIFIER_INTENT_NO_TEXT_INPUT,
            ModifierIntent::ShiftGroup => ffi::GDK_MODIFIER_INTENT_SHIFT_GROUP,
            ModifierIntent::DefaultModMask => ffi::GDK_MODIFIER_INTENT_DEFAULT_MOD_MASK,
            ModifierIntent::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkModifierIntent> for ModifierIntent {
    fn from_glib(value: ffi::GdkModifierIntent) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_MODIFIER_INTENT_PRIMARY_ACCELERATOR => ModifierIntent::PrimaryAccelerator,
            ffi::GDK_MODIFIER_INTENT_CONTEXT_MENU => ModifierIntent::ContextMenu,
            ffi::GDK_MODIFIER_INTENT_EXTEND_SELECTION => ModifierIntent::ExtendSelection,
            ffi::GDK_MODIFIER_INTENT_MODIFY_SELECTION => ModifierIntent::ModifySelection,
            ffi::GDK_MODIFIER_INTENT_NO_TEXT_INPUT => ModifierIntent::NoTextInput,
            ffi::GDK_MODIFIER_INTENT_SHIFT_GROUP => ModifierIntent::ShiftGroup,
            ffi::GDK_MODIFIER_INTENT_DEFAULT_MOD_MASK => ModifierIntent::DefaultModMask,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NotifyType {
    Ancestor,
    Virtual,
    Inferior,
    Nonlinear,
    NonlinearVirtual,
    Unknown,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for NotifyType {
    type GlibType = ffi::GdkNotifyType;

    fn to_glib(&self) -> ffi::GdkNotifyType {
        match *self {
            NotifyType::Ancestor => ffi::GDK_NOTIFY_ANCESTOR,
            NotifyType::Virtual => ffi::GDK_NOTIFY_VIRTUAL,
            NotifyType::Inferior => ffi::GDK_NOTIFY_INFERIOR,
            NotifyType::Nonlinear => ffi::GDK_NOTIFY_NONLINEAR,
            NotifyType::NonlinearVirtual => ffi::GDK_NOTIFY_NONLINEAR_VIRTUAL,
            NotifyType::Unknown => ffi::GDK_NOTIFY_UNKNOWN,
            NotifyType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkNotifyType> for NotifyType {
    fn from_glib(value: ffi::GdkNotifyType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_NOTIFY_ANCESTOR => NotifyType::Ancestor,
            ffi::GDK_NOTIFY_VIRTUAL => NotifyType::Virtual,
            ffi::GDK_NOTIFY_INFERIOR => NotifyType::Inferior,
            ffi::GDK_NOTIFY_NONLINEAR => NotifyType::Nonlinear,
            ffi::GDK_NOTIFY_NONLINEAR_VIRTUAL => NotifyType::NonlinearVirtual,
            ffi::GDK_NOTIFY_UNKNOWN => NotifyType::Unknown,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum OwnerChange {
    NewOwner,
    Destroy,
    Close,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for OwnerChange {
    type GlibType = ffi::GdkOwnerChange;

    fn to_glib(&self) -> ffi::GdkOwnerChange {
        match *self {
            OwnerChange::NewOwner => ffi::GDK_OWNER_CHANGE_NEW_OWNER,
            OwnerChange::Destroy => ffi::GDK_OWNER_CHANGE_DESTROY,
            OwnerChange::Close => ffi::GDK_OWNER_CHANGE_CLOSE,
            OwnerChange::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkOwnerChange> for OwnerChange {
    fn from_glib(value: ffi::GdkOwnerChange) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_OWNER_CHANGE_NEW_OWNER => OwnerChange::NewOwner,
            ffi::GDK_OWNER_CHANGE_DESTROY => OwnerChange::Destroy,
            ffi::GDK_OWNER_CHANGE_CLOSE => OwnerChange::Close,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PropertyState {
    NewValue,
    Delete,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PropertyState {
    type GlibType = ffi::GdkPropertyState;

    fn to_glib(&self) -> ffi::GdkPropertyState {
        match *self {
            PropertyState::NewValue => ffi::GDK_PROPERTY_NEW_VALUE,
            PropertyState::Delete => ffi::GDK_PROPERTY_DELETE,
            PropertyState::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkPropertyState> for PropertyState {
    fn from_glib(value: ffi::GdkPropertyState) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_PROPERTY_NEW_VALUE => PropertyState::NewValue,
            ffi::GDK_PROPERTY_DELETE => PropertyState::Delete,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollDirection {
    Up,
    Down,
    Left,
    Right,
    Smooth,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ScrollDirection {
    type GlibType = ffi::GdkScrollDirection;

    fn to_glib(&self) -> ffi::GdkScrollDirection {
        match *self {
            ScrollDirection::Up => ffi::GDK_SCROLL_UP,
            ScrollDirection::Down => ffi::GDK_SCROLL_DOWN,
            ScrollDirection::Left => ffi::GDK_SCROLL_LEFT,
            ScrollDirection::Right => ffi::GDK_SCROLL_RIGHT,
            ScrollDirection::Smooth => ffi::GDK_SCROLL_SMOOTH,
            ScrollDirection::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkScrollDirection> for ScrollDirection {
    fn from_glib(value: ffi::GdkScrollDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_SCROLL_UP => ScrollDirection::Up,
            ffi::GDK_SCROLL_DOWN => ScrollDirection::Down,
            ffi::GDK_SCROLL_LEFT => ScrollDirection::Left,
            ffi::GDK_SCROLL_RIGHT => ScrollDirection::Right,
            ffi::GDK_SCROLL_SMOOTH => ScrollDirection::Smooth,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SettingAction {
    New,
    Changed,
    Deleted,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SettingAction {
    type GlibType = ffi::GdkSettingAction;

    fn to_glib(&self) -> ffi::GdkSettingAction {
        match *self {
            SettingAction::New => ffi::GDK_SETTING_ACTION_NEW,
            SettingAction::Changed => ffi::GDK_SETTING_ACTION_CHANGED,
            SettingAction::Deleted => ffi::GDK_SETTING_ACTION_DELETED,
            SettingAction::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkSettingAction> for SettingAction {
    fn from_glib(value: ffi::GdkSettingAction) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_SETTING_ACTION_NEW => SettingAction::New,
            ffi::GDK_SETTING_ACTION_CHANGED => SettingAction::Changed,
            ffi::GDK_SETTING_ACTION_DELETED => SettingAction::Deleted,
        }
    }
}

#[cfg(feature = "v3_22")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SubpixelLayout {
    Unknown,
    None,
    HorizontalRgb,
    HorizontalBgr,
    VerticalRgb,
    VerticalBgr,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_22")]
#[doc(hidden)]
impl ToGlib for SubpixelLayout {
    type GlibType = ffi::GdkSubpixelLayout;

    fn to_glib(&self) -> ffi::GdkSubpixelLayout {
        match *self {
            SubpixelLayout::Unknown => ffi::GDK_SUBPIXEL_LAYOUT_UNKNOWN,
            SubpixelLayout::None => ffi::GDK_SUBPIXEL_LAYOUT_NONE,
            SubpixelLayout::HorizontalRgb => ffi::GDK_SUBPIXEL_LAYOUT_HORIZONTAL_RGB,
            SubpixelLayout::HorizontalBgr => ffi::GDK_SUBPIXEL_LAYOUT_HORIZONTAL_BGR,
            SubpixelLayout::VerticalRgb => ffi::GDK_SUBPIXEL_LAYOUT_VERTICAL_RGB,
            SubpixelLayout::VerticalBgr => ffi::GDK_SUBPIXEL_LAYOUT_VERTICAL_BGR,
            SubpixelLayout::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_22")]
#[doc(hidden)]
impl FromGlib<ffi::GdkSubpixelLayout> for SubpixelLayout {
    fn from_glib(value: ffi::GdkSubpixelLayout) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_SUBPIXEL_LAYOUT_UNKNOWN => SubpixelLayout::Unknown,
            ffi::GDK_SUBPIXEL_LAYOUT_NONE => SubpixelLayout::None,
            ffi::GDK_SUBPIXEL_LAYOUT_HORIZONTAL_RGB => SubpixelLayout::HorizontalRgb,
            ffi::GDK_SUBPIXEL_LAYOUT_HORIZONTAL_BGR => SubpixelLayout::HorizontalBgr,
            ffi::GDK_SUBPIXEL_LAYOUT_VERTICAL_RGB => SubpixelLayout::VerticalRgb,
            ffi::GDK_SUBPIXEL_LAYOUT_VERTICAL_BGR => SubpixelLayout::VerticalBgr,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum VisibilityState {
    Unobscured,
    Partial,
    FullyObscured,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for VisibilityState {
    type GlibType = ffi::GdkVisibilityState;

    fn to_glib(&self) -> ffi::GdkVisibilityState {
        match *self {
            VisibilityState::Unobscured => ffi::GDK_VISIBILITY_UNOBSCURED,
            VisibilityState::Partial => ffi::GDK_VISIBILITY_PARTIAL,
            VisibilityState::FullyObscured => ffi::GDK_VISIBILITY_FULLY_OBSCURED,
            VisibilityState::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkVisibilityState> for VisibilityState {
    fn from_glib(value: ffi::GdkVisibilityState) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_VISIBILITY_UNOBSCURED => VisibilityState::Unobscured,
            ffi::GDK_VISIBILITY_PARTIAL => VisibilityState::Partial,
            ffi::GDK_VISIBILITY_FULLY_OBSCURED => VisibilityState::FullyObscured,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum VisualType {
    StaticGray,
    Grayscale,
    StaticColor,
    PseudoColor,
    TrueColor,
    DirectColor,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for VisualType {
    type GlibType = ffi::GdkVisualType;

    fn to_glib(&self) -> ffi::GdkVisualType {
        match *self {
            VisualType::StaticGray => ffi::GDK_VISUAL_STATIC_GRAY,
            VisualType::Grayscale => ffi::GDK_VISUAL_GRAYSCALE,
            VisualType::StaticColor => ffi::GDK_VISUAL_STATIC_COLOR,
            VisualType::PseudoColor => ffi::GDK_VISUAL_PSEUDO_COLOR,
            VisualType::TrueColor => ffi::GDK_VISUAL_TRUE_COLOR,
            VisualType::DirectColor => ffi::GDK_VISUAL_DIRECT_COLOR,
            VisualType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkVisualType> for VisualType {
    fn from_glib(value: ffi::GdkVisualType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_VISUAL_STATIC_GRAY => VisualType::StaticGray,
            ffi::GDK_VISUAL_GRAYSCALE => VisualType::Grayscale,
            ffi::GDK_VISUAL_STATIC_COLOR => VisualType::StaticColor,
            ffi::GDK_VISUAL_PSEUDO_COLOR => VisualType::PseudoColor,
            ffi::GDK_VISUAL_TRUE_COLOR => VisualType::TrueColor,
            ffi::GDK_VISUAL_DIRECT_COLOR => VisualType::DirectColor,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowEdge {
    NorthWest,
    North,
    NorthEast,
    West,
    East,
    SouthWest,
    South,
    SouthEast,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WindowEdge {
    type GlibType = ffi::GdkWindowEdge;

    fn to_glib(&self) -> ffi::GdkWindowEdge {
        match *self {
            WindowEdge::NorthWest => ffi::GDK_WINDOW_EDGE_NORTH_WEST,
            WindowEdge::North => ffi::GDK_WINDOW_EDGE_NORTH,
            WindowEdge::NorthEast => ffi::GDK_WINDOW_EDGE_NORTH_EAST,
            WindowEdge::West => ffi::GDK_WINDOW_EDGE_WEST,
            WindowEdge::East => ffi::GDK_WINDOW_EDGE_EAST,
            WindowEdge::SouthWest => ffi::GDK_WINDOW_EDGE_SOUTH_WEST,
            WindowEdge::South => ffi::GDK_WINDOW_EDGE_SOUTH,
            WindowEdge::SouthEast => ffi::GDK_WINDOW_EDGE_SOUTH_EAST,
            WindowEdge::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkWindowEdge> for WindowEdge {
    fn from_glib(value: ffi::GdkWindowEdge) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_WINDOW_EDGE_NORTH_WEST => WindowEdge::NorthWest,
            ffi::GDK_WINDOW_EDGE_NORTH => WindowEdge::North,
            ffi::GDK_WINDOW_EDGE_NORTH_EAST => WindowEdge::NorthEast,
            ffi::GDK_WINDOW_EDGE_WEST => WindowEdge::West,
            ffi::GDK_WINDOW_EDGE_EAST => WindowEdge::East,
            ffi::GDK_WINDOW_EDGE_SOUTH_WEST => WindowEdge::SouthWest,
            ffi::GDK_WINDOW_EDGE_SOUTH => WindowEdge::South,
            ffi::GDK_WINDOW_EDGE_SOUTH_EAST => WindowEdge::SouthEast,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowType {
    Root,
    Toplevel,
    Child,
    Temp,
    Foreign,
    Offscreen,
    Subsurface,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WindowType {
    type GlibType = ffi::GdkWindowType;

    fn to_glib(&self) -> ffi::GdkWindowType {
        match *self {
            WindowType::Root => ffi::GDK_WINDOW_ROOT,
            WindowType::Toplevel => ffi::GDK_WINDOW_TOPLEVEL,
            WindowType::Child => ffi::GDK_WINDOW_CHILD,
            WindowType::Temp => ffi::GDK_WINDOW_TEMP,
            WindowType::Foreign => ffi::GDK_WINDOW_FOREIGN,
            WindowType::Offscreen => ffi::GDK_WINDOW_OFFSCREEN,
            WindowType::Subsurface => ffi::GDK_WINDOW_SUBSURFACE,
            WindowType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkWindowType> for WindowType {
    fn from_glib(value: ffi::GdkWindowType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_WINDOW_ROOT => WindowType::Root,
            ffi::GDK_WINDOW_TOPLEVEL => WindowType::Toplevel,
            ffi::GDK_WINDOW_CHILD => WindowType::Child,
            ffi::GDK_WINDOW_TEMP => WindowType::Temp,
            ffi::GDK_WINDOW_FOREIGN => WindowType::Foreign,
            ffi::GDK_WINDOW_OFFSCREEN => WindowType::Offscreen,
            ffi::GDK_WINDOW_SUBSURFACE => WindowType::Subsurface,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowTypeHint {
    Normal,
    Dialog,
    Menu,
    Toolbar,
    Splashscreen,
    Utility,
    Dock,
    Desktop,
    DropdownMenu,
    PopupMenu,
    Tooltip,
    Notification,
    Combo,
    Dnd,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WindowTypeHint {
    type GlibType = ffi::GdkWindowTypeHint;

    fn to_glib(&self) -> ffi::GdkWindowTypeHint {
        match *self {
            WindowTypeHint::Normal => ffi::GDK_WINDOW_TYPE_HINT_NORMAL,
            WindowTypeHint::Dialog => ffi::GDK_WINDOW_TYPE_HINT_DIALOG,
            WindowTypeHint::Menu => ffi::GDK_WINDOW_TYPE_HINT_MENU,
            WindowTypeHint::Toolbar => ffi::GDK_WINDOW_TYPE_HINT_TOOLBAR,
            WindowTypeHint::Splashscreen => ffi::GDK_WINDOW_TYPE_HINT_SPLASHSCREEN,
            WindowTypeHint::Utility => ffi::GDK_WINDOW_TYPE_HINT_UTILITY,
            WindowTypeHint::Dock => ffi::GDK_WINDOW_TYPE_HINT_DOCK,
            WindowTypeHint::Desktop => ffi::GDK_WINDOW_TYPE_HINT_DESKTOP,
            WindowTypeHint::DropdownMenu => ffi::GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU,
            WindowTypeHint::PopupMenu => ffi::GDK_WINDOW_TYPE_HINT_POPUP_MENU,
            WindowTypeHint::Tooltip => ffi::GDK_WINDOW_TYPE_HINT_TOOLTIP,
            WindowTypeHint::Notification => ffi::GDK_WINDOW_TYPE_HINT_NOTIFICATION,
            WindowTypeHint::Combo => ffi::GDK_WINDOW_TYPE_HINT_COMBO,
            WindowTypeHint::Dnd => ffi::GDK_WINDOW_TYPE_HINT_DND,
            WindowTypeHint::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkWindowTypeHint> for WindowTypeHint {
    fn from_glib(value: ffi::GdkWindowTypeHint) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_WINDOW_TYPE_HINT_NORMAL => WindowTypeHint::Normal,
            ffi::GDK_WINDOW_TYPE_HINT_DIALOG => WindowTypeHint::Dialog,
            ffi::GDK_WINDOW_TYPE_HINT_MENU => WindowTypeHint::Menu,
            ffi::GDK_WINDOW_TYPE_HINT_TOOLBAR => WindowTypeHint::Toolbar,
            ffi::GDK_WINDOW_TYPE_HINT_SPLASHSCREEN => WindowTypeHint::Splashscreen,
            ffi::GDK_WINDOW_TYPE_HINT_UTILITY => WindowTypeHint::Utility,
            ffi::GDK_WINDOW_TYPE_HINT_DOCK => WindowTypeHint::Dock,
            ffi::GDK_WINDOW_TYPE_HINT_DESKTOP => WindowTypeHint::Desktop,
            ffi::GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU => WindowTypeHint::DropdownMenu,
            ffi::GDK_WINDOW_TYPE_HINT_POPUP_MENU => WindowTypeHint::PopupMenu,
            ffi::GDK_WINDOW_TYPE_HINT_TOOLTIP => WindowTypeHint::Tooltip,
            ffi::GDK_WINDOW_TYPE_HINT_NOTIFICATION => WindowTypeHint::Notification,
            ffi::GDK_WINDOW_TYPE_HINT_COMBO => WindowTypeHint::Combo,
            ffi::GDK_WINDOW_TYPE_HINT_DND => WindowTypeHint::Dnd,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowWindowClass {
    InputOutput,
    InputOnly,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WindowWindowClass {
    type GlibType = ffi::GdkWindowWindowClass;

    fn to_glib(&self) -> ffi::GdkWindowWindowClass {
        match *self {
            WindowWindowClass::InputOutput => ffi::GDK_INPUT_OUTPUT,
            WindowWindowClass::InputOnly => ffi::GDK_INPUT_ONLY,
            WindowWindowClass::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkWindowWindowClass> for WindowWindowClass {
    fn from_glib(value: ffi::GdkWindowWindowClass) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GDK_INPUT_OUTPUT => WindowWindowClass::InputOutput,
            ffi::GDK_INPUT_ONLY => WindowWindowClass::InputOnly,
        }
    }
}

